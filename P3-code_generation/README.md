\ ## Phase 3 QUICK COMMANDS
> 1. `mil_run mil_code.mil`
> 2. `mil_run mil_code.mil < input.txt`
> 3. `mil_run`
> 4. `cat fibonacci.min | my_compiler`
> 5. `echo 5 > input.txt mil_run fibonacci.mil < input.txt`

# Project
### Phase III 
## Overview
We need to check that variables declared before they are used. In the case of a grammatically (syntactically) correct program, it might not make sense because of the declarations. How do we programmatically check that the variables (variable references) have been correctly declared? We can implement the following program:
  1. Go over all variable declarations.                                                                  
  2. For every variable declaration you encounter, collect all necessary information about the declared variable.
  3. Store the collected information in some stash for future reference by using the variable's name as a key.
  4. When you see a variable reference such as the assignment statement `x := x + y` search the stash bhy the variable's  name to see if the stash haas any information about the variable. If it does, the variable has been declared yet, which is a semantic error.

Our compiler needs to answer the following questions:
  + What information about the variables do we need to collect?
  + Where and how do we store the collected information from the previous step?
  + How do we implement the step to go over all variable declarations (step 1 in the algorithm) ?

  ### What information about the variables do we need to collect?
    + **Name:** we need to know the name of a declared variable because later we have to look them up by name.
    + **Category:** we need to know what kind of an identifier it is:
      + variable
      + type
      + procedure
      + etc.
    + **Type:** we need this information to perform type checking
    ---
    Symbols!
    A symbol is an identifier of some entity for the program. Ie, variable, subroutine, built-in variable, etc.

  ### Where and how do we store the collected information from the previous step?
    Symbol Table:
    + Abstract data type for tracking various symbols in source code. 
    + Manually populate symbol table for the sample program.
    + Variable references + declarations
  ### How do we implement the step to go over all variable declarations (step 1 in the algorithm) ?
    + build an AST by the parser
    + create an AST visitor class responsible for walking over the tree and doing different actions when visiting VarDecl AST nodes
    + said AST visiter for every VarDecl will store the collected information about the variable declaration in the symbol table using the symbol table's insert method.
    + Add method to symbol table that will be able to look up a symbol by name
    + We need to update our semantic analyzer to look up a name in the symbol table every time it encounters a variable reference.
    + Add the look up method that will be responsible for searching for a symbol by name. In other words, the lookup method will be responsible for resolving a variable name (a variable reference) to its declaration. THIS IS NAME RESOLUTION.




```
## Overview 
 - In the previous phases of the class project, you used the flex and bison tools to create a lexical analyzer and a parser for the "MINI-L" programming language. In this phase of the class project, you will take a syntactically-correct MINI-L program (a program that can be parsed without any syntax errors), verify that it has no semantic errors, and then generate its corresponding intermediate code. The generated code can then be executed (using a tool we will provide) to run the compiled MINI-L program.
- You should perform one-pass code generation and directly output the generated code. There is no need to build/traverse a syntax tree. However, you will need to maintain a symbol table during code generation.
- The intermediate code you will generate is called "MIL" code. We will provide you with an interpreter called mil_run that can be used to execute the MIL code.
- The output of your code generator will be a file containing the generated MIL code. If any semantic errors are encountered by the code generator, then appropriate error messages should be emitted and no other output should be produced. 
### The `mil_run` MIL interpreter 
 We are providing an interpreter for MIL intermediate code (`mil_run`), which can be used to execute the MIL code generated by your code generator. The `mil_run` interpreter requires an input file to be specified that contains the MIL code that should be executed. For example, if you have MIL code contained in a file called `mil_code.mil`, then you can execute the MIL code with the following command:
```shell
mil_run mil_code.mil
```
If the MIL code itself requires some input data, this input data can be written to a file and then redirected to the executing MIL code. For example, if the input values are written to a text file called `input.txt`, then it can be passed to the executing MIL program as follows:
```shell
mil_run mil_code.mil < input.txt
```
The `mil_run` interpreter will generate a file called milRun.stat that contains some statistics about the MIL code that was just executed. You may ignore this file.
`mil_run` makes the following assumptions.
  1. Each line in the MIL file contains at most one MIL instruction
  2. Each line is at most 254 characters long
  3. All variables are defined before they are used 
You must ensure that your generated MIL code meets the above three requirements.

mil_run is a linux executable and can be run on bolt. 
### Detailed Requirements 
1.  You will need to modify your `bison` specification file from the previous phase of the class project so that it no longer outputs the list of productions taken during parsing.
2. Implement the code generator. This will most likely require some enhancements to your `bison` specification file. You may also want to create additional implementation files. The requirements for your implementation are as follows.
 a. You do not need to do anything special to handle lexical or syntax errors in this phase of the class project. If any lexical or syntax errors are encountered, your compiler should emit appropriate error message(s) and terminate the same way as was done in previous phases.
 b. You need to check for semantic errors in the inputted MINI-L program. During code generation, if any semantic errors are encountered, then appropriate error messages should be emitted and no other output should be produced (i.e., no code should be generated).
 c. If no semantic errors are encountered, then the appropriate MIL intermediate code should be generated and written to stdout.
 d. When generating the intermediate code, be careful that you do not accidentally create a temporary variable with the same name as one of the variables specified in the original MINI-L program. 
3. Compile everything together into a single executable. The particular commands needed to compile your code generator will depend on the implementation files you create.
4. Use the `mil_run` MIL interpreter to test your implementation. For each program written in MINI-L source code, compile it down to MIL code using your implementation. Then invoke the MIL code using `mil_run` to verify that the compiled program behaves as expected.
#### Example usage 
Suppose your code generator is in the executable named `my_compiler`. Then for the MINI-L program `fibonacci.min` (which is syntactically and semantically correct), your code generator should be invoked as follows: 
```shell
cat fibonacci.min | my_compiler 
```
The file `fibonacci.mil` should then be created and should contain the generated MIL code (it is okay if your generated code looks slightly different, but it should have the same behavior when executed). Next, you can test your generated code using the `mil_run` MIL interpreter to ensure that it behaves as expected. Suppose we want to run the compiled `fibonacci` program with input "`5`": 
```shell
echo 5 > input.txt
mil_run fibonacci.mil < input.txt 
```
When the compiled `fibonacci` program is executed with the above input "`5`", then the fifth fibonacci number is printed to the screen: 
```jsunicoderegexp
8 
```

### A Note About Runtime Errors
There are some errors that cannot always be captured at compile-time and may only happen at run-time. These errors include those such as array index out-of-bounds errors, and division by zero. Your implementation need not handle these errors. You may assume that when we grade your programs, we will not use any MINI-L programs that would lead to run-time errors. Note also that the `mil_run` MIL interpreter we are providing may have unexpected behavior if you try to run it on a program that can lead to run-time problems (such as an out-of-bounds array access). Thus, when you are testing your implementation, try to make sure your MINI-L programs will not cause any run-time errors.
```
